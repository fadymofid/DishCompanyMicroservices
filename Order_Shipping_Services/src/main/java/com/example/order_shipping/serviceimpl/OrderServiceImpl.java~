package com.example.order_shipping.serviceimpl;

import com.example.order_shipping.dto.OrderItemRequest;
import com.example.order_shipping.dto.OrderRequest;
import com.example.order_shipping.dto.OrderResponse;
import com.example.order_shipping.exception.InsufficientStockException;
import com.example.order_shipping.exception.MinimumChargeException;
import com.example.order_shipping.exception.ShippingUnavailableException;
import com.example.order_shipping.model.Order;
import com.example.order_shipping.model.OrderItem;
import com.example.order_shipping.repository.OrderRepository;
import com.example.order_shipping.service.OrderService;
import com.example.order_shipping.service.ShippingService;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.server.ResponseStatusException;

import java.math.BigDecimal;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class OrderServiceImpl implements OrderService {
    private static final BigDecimal MINIMUM_CHARGE = new BigDecimal("20.00");

    private final OrderRepository orderRepository;
    private final RabbitTemplate rabbitTemplate;
    private final ShippingService shippingService;

    @Autowired
    public OrderServiceImpl(OrderRepository orderRepository,
                            RabbitTemplate rabbitTemplate,
                            ShippingService shippingService) {
        this.orderRepository = orderRepository;
        this.rabbitTemplate = rabbitTemplate;
        this.shippingService = shippingService;
    }

    @Override
    @Transactional
    public OrderResponse processOrder(OrderRequest request) {
        // 1. Validate shipping region (throws ResponseStatusException on failure)
        try {
            shippingService.validateShippingRegion(
                    request.getShippingCompanyId(),
                    request.getCustomerRegion()
            );
        } catch (ResponseStatusException ex) {
            // Already sent RabbitMQ notification inside validateShippingRegion
            throw ex;
        }

        // 2. Publish stock-check event
        rabbitTemplate.convertAndSend("order-exchange", "stock.check", request);

        // 3. Wait for stock validation (this could be async; stubbed here)
        boolean stockOk = listenForStockValidation(request.getOrderId());
        if (!stockOk) {
            rabbitTemplate.convertAndSend(
                    "order-exchange", "order.rejected",
                    "Insufficient stock for order " + request.getOrderId()
            );
            throw new ResponseStatusException(
                    HttpStatus.BAD_REQUEST,
                    "Insufficient stock for one or more items"
            );
        }

        // 4. Calculate total with shipping fee
        BigDecimal itemsTotal = calculateItemsTotal(request.getItems());
        BigDecimal shippingFee = shippingService.calculateShippingFee(
                request.getShippingCompanyId(), request.getCustomerRegion()
        );
        BigDecimal total = itemsTotal.add(shippingFee);

        // 5. Check minimum charge
        if (total.compareTo(MINIMUM_CHARGE) < 0) {
            rabbitTemplate.convertAndSend(
                    "order-exchange", "order.rejected",
                    "Order below minimum charge: " + total
            );
            throw new ResponseStatusException(
                    HttpStatus.PAYMENT_REQUIRED,
                    String.format("Order total %s is below minimum %s", total, MINIMUM_CHARGE)
            );
        }

        // 6. Persist order
        Order order = new Order();
        order.setCustomerId(request.getCustomerId());
        order.setShippingCompanyId(request.getShippingCompanyId());
        order.setTotalAmount(total);
        List<OrderItem> items = request.getItems().stream().map(reqItem -> {
            OrderItem oi = new OrderItem();
            oi.setDishId(reqItem.getDishId());
            oi.setQuantity(reqItem.getQuantity());
            oi.setOrder(order);
            return oi;
        }).collect(Collectors.toList());
        order.setItems(items);
        orderRepository.save(order);

        // 7. Publish order confirmed
        rabbitTemplate.convertAndSend("order-exchange", "order.confirmed", order.getId());

        return new OrderResponse(order.getId(), order.getStatus(), total);
    }

    private BigDecimal calculateItemsTotal(List<OrderItemRequest> items) {
        return items.stream()
                .map(i -> i.getPrice().multiply(new BigDecimal(i.getQuantity())))
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    private boolean listenForStockValidation(Long orderId) {
        // Placeholder: in real app, this might block on a CompletableFuture tied to a listener
        return true;
    }
}
